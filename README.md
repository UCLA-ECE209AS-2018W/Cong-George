# ECE209AS Course project: House Occupacy Detection Via WiFi Packets Sniffing



## Abstract

In this paper we implemented a novel method to infer house occupancy only by looking at the enccypted 802.11 wifi traffic between client devices in the house and the wifi access point at the house. Using the wifi signature method proposed by two Google engineers, our device is able to identify the type of all devices in the target network. By checking the present of smartphones in the current network, a strong indicator of occupancy as most American adults always carry cellphone with them, our script is capable of tracking the house occupancy very accurately. 

## Introduciton

As the concept of Internet of things are prevailing these days, more and more family choose to use them in house as a center of controll for other in-house IoT devices. For example, Google home can be associated with smart door lock or smart lamp for remote voice controll. While these devices greatly facilitate our daily life, it also exposes security issues.

To be more sepecific, devices such as Google Home, or Amazon Alexa will need to be connected to the network in order to fully enforce it's functionality. Even though nowadays the wifi packets are encrypted and are almost impossible to be decrypted, we still find a way to characterize different devices presented in the room by parsing the 802.11 frame headers which are not encrypted and can be analyzed automatically by tools such as whireshark. We demonstrate that by just using the information in the 802.11 frame header, we can form the wifi signature of differnt device. After we gathering enough informaiton and forming the signiture of each device, we can compare each new snipped wifi packet generated by unknow device and indentify possible known device by generating signatures from the new packet and compare it with exsiting signatures. Lastly, by how devices are detected within certain period, we can infer the room occupancy.   

## Background

As our approach relies on forming wifi signature from 802.11 frame heavily, we will be briefly going over the 802.11 frame header information as well as the concept of wifi signature. We assume that readers are familiar with network's osi 4-layer architecture as well as packet dumping tools such as wireshark. Also, we are assuming that readers are familiar with basic procedure of how devices can be connected to the network via access point(AP). We will also briefly introduce kali Linux operating system which is our wokring envirionment.

* **802.11 frame**    
802.11 frame is a header that is appened to the packets that are passed down from higher transport layer, information related to medium access control layer(MAC layer) will be added to the the header. All the realted data get passed down from the upper layer will be the payload of 802.11 frame and will be encrypted. However, the 802.11 frame header will not be encrypted and can be grabbed and parsed by tools such as wireshark. Let's take a look at the details of the contend of the header:  

![alt text][frame]

[frame]: https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/Screen%20Shot%202018-03-19%20at%201.02.36%20PM.png  

The information in the header contains both sender and receiver information as well as packet type and some other information you can refer to [this site](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc757419(v=ws.10)) for a detailed information, our approach only focuses on two specific type of packets: **probing packet(frame)** and **association packet(frame)** in MLME

* **WiFi Management Layer Identity(MLME)**  
MLME compromises a number of different types of packets with fixed parameters in 802.11 frame and are followed by other parameters suc as tagged parameters, optional fields. Also, different vendor will also add thier own parameters to the packet, which make packets sent by different devices easy of identify. Among all those MLME packets, our approach leverage the content of **Probe Frames** and **Association Frame**.

**Probe frame**: sent by clients searching for an access point for any available AP, information included in the probe frame may be capabilites such as encodings, supported rates, authentication capabilities, supported MAC and so on.  

**Association frame**: sent by clients to ask the AP to add clients themselved to the WLAN.  

**Deauthentification Frame**: sent by both client and AP to terminate the communication and client disconnect with AP.
Our approach relies on these three frame to identify devices and infer house acticity.

**WiFi Signature**  
In order for AP to handle probe and association request, AP examines the serires tagged parameters from clientsextracting those and used them as WiFi signatures. Since wifi signatures reflects a combination of the specific wifi chipset, device driver, WPA supplicant and PCB layout of the client device, they are capable of identidying differnt devices. The figure below shows the wifi signatures of differnt mobile phones.

## **Method**
In this section, we introduced a few methods we have tried in this project. Before we finally settled on the wifi signature method, there were also a few failed attempts. Although these method did not work out eventually, it is still worth talking about as they did bring much insights to help us to find the final working solution.

#### **Motivation**
Inspired by [Spying on the Smart Home: Privacy Attacks and Defenses on Encrypted IoT Traffic](https://arxiv.org/pdf/1708.05044.pdf), despite that information in 802.11 raw packets sniffed from the air is very well encrypted by latest WPA2 encrytion method and is very difficult to decrypted, personal privacy information can be still distilled from the encrypted packets traffic analysis. Although data contained in the upper layer of the packet are encrytpted, the ethernet (mac) layer and radio link information are transparent, giving sniffer the opportunity to learn the frame type, packet size and etc of a traffic from certain device in the network at any time. Depending on the hardware/software configuration and usage of a smart device, its traffic pattern may also vary accordingly. As discovered by researchers in [Is Anybody Home? Inferring Activity From Smart Home Network Traffic](http://ieeexplore.ieee.org/document/7527776/?reload=true), smart home devices collect, exchange, and transmit various data about the environment of our homes. This data can not only be used to characterize a physical property but also to infer personal information about the inhabitants. Traffic classification can be used as a source for covert channel attacks. Specifically, traffic classification techniques can infer events taking place within a building. 

#### **Traffic Classification Attempt**
Follow the trace of these related work, in the very beginning of this project, we seeked to infer the house occupancy from encypted 802.11 packet traffic classification. We tried to look for possible correlation between sniffed packets traffic pattern and smart device usage activities. Motivated by the method introduced in [Deep Packet: A Novel Approach For Encrypted Traffic Classification Using Deep Learning](https://arxiv.org/pdf/1709.02656.pdf), we adopted a similar approach - sniff 802.11 packets for a certain period of time and feed in features extracted from the traffic into a machine learning model for analysis. 

However, since we have no idea about the house host's living habbits, such as what smart devices he/she has, what applications they use and when to use it, traffic pattern could be totally different for different people. Even for the same person, his/her network usage may also change drastically due to many factors such as time of the day, weather and etc. Therefore, there is no way we could train a supervised machine learning model to perform the pattern classfication because simply we have no idea what the pattern would look like (this project will also be meaningless if we do know). Given this fact, a supervised deep learning model does not apply to our situation and we need a unsupervised machine learning model to classfy the network traffic. Therefore, we choosed a simple k-mean cluster model for the traffic analysis. After all, we only need the model to distinguish between two traffic pattern - when there is people home and when there is not, so k is simply equal to two. We also extract five feature such as number of data packets, number of devices,  number of null data packets and etc. These features will be calculated every 30 minutes and feed in the k-mean cluster model. At the end of the day, the model will finish its training and give out a pattern summary labeling the occupancy of each period (48 period in a day). 

We spent the first few week to implement this method and the classfication result was horrible if not disastrous. Even after we tuning the model and facilitate the feature extraction process, the result still did not improve a bit. It turns out this naive traffic classfication attempt did not work as expected due to three major reasons:

* Inability to capture all data packets
Contrary to what we expected, wireless sniffing adapter is actually unable to capture all data packets directed from or to a ceratin device. This is because 802.11n has a special facility called "Greenfield" or "HT" (High throughput) mode that allows data to be transmitted between AP and device with ultra-high speed. We found this special facility is widely apadted in smart devices nowadays and data are transfering in between AP (router) and smart device such as cellphones with a speed higher than what our sniffing device could handle. Therefore, the data packets we captured only makes a very small fraction of total data transfer and most of data traffic were actually unobserved. We were only able to capture data packets that are not transferred via HT mode such as the three-way handshake process packets. Once connection is established, data will be transferred with a much higher rate which our adpater could not handle. Not to mentioned our adpator is reside in a rather noisy environment with in-the-air traffic from more than 20 devices at the same floor of my apartment building. This had been proved in our experiment - no obvious difference in the number of data packets between a idle and a highly active device. 

* Feature Dependency of the Unsupervised Clustering Model
Another major cause resides in features extracted from captured traffic. There are too much redundancy/dependency between features input to the machine learning model and thus leading to inaccuracy. For example, the feature "number of active device in network" has high dependency with the other feature "number of data packets". To be honest, there are very few features we could extracte from encrypted wifi traffic. In the sense that we use unsupervised models, there is no way to evaluate the feature importance and adjust weights accordingly. Furthermore, we can barely understand the metrics behind the clustering results. For example, although we expect the output two cluster representing time periods where people are at home or not, the actual underlying relationship between these two cluster could however indictate when is the target watching movies on laptop or not. 

* Network Activity Insufficient to Indicate House Occupancy
The fundamental reason that behind the failure of this approach is that we made a incorrect assumption about the relation between network traffic and house occupancy. Previously, we associate house occupancy with active network activity and naively assume active wifi traffic entails house occupancy and vise versa. Nevertheless, inactive traffic does NOT indicate house vacancy at all. Our clustering model always cluster night-time periods with actual vacant periods. It is highly likely that traffic pattern at nighttime where occupants of a house are not using smart device (sleeping) very much resembles periods when the house is actually vacant. Due to this observation, we finally realized that the traffic classfication approach is rather futile as network activity is a insufficient indicator of house occupancy.

#### **Cellphone Fingerprinting**
Rather focusing on traffic classfication, we later shifted to another approach - fingerprint all cellphones in the house. If any cellphone is detected in the network, then the house is not vacant and vise versa. This may rather sound like a very reckless claim, however, according to this [survey](http://www.pewinternet.org/2015/08/26/chapter-1-always-on-connectivity/), 92% American Adults own at least one cellphone and 67% of them are smartphones with Wifi capability. Furthermore, 90% of American adults carry cellphone with them wherever and about 80% of all adults never turn their cellphones off. Based on these numbers this survey, we believe the present of cellphone is a good indicator of house occupancy. Still there are a few assumptions we made for our approach to work as expected:

- The target house has a wifi AP (router)
- Occupants of target house have smartphones with wifi capabilities
- Occupants take cellphone with them when they leave the house
- Occupants do not turn off their cellphones at night and so remain in the network
- Smartphones of Occupants connect with house AP automatically

#### **Device Fingerprinting with probe request frames**
A very famous technique to fingerprint devices in the network is through probe request monitoring. Probe request frames as introduced in the background section, is one type of management frame which devices broadcast constantly in search for possible AP nodes to connect with. In a process called active scanning, client will send out probe request frames periodically to scan an area for a wireless access point. This is also a well-known loophole of 802.11 that put smart device users' privacy at risk. Demonstrates by researchers in the paper [Identifying unique devices through wireless fingerprinting](https://dl.acm.org/citation.cfm?id=1352542&dl=ACM&coll=DL), time interval between consecutive probe request of a device is dependent on its hardware configuration, wireless NIC driver and operating system. BY performing a timing analysis on probe request of a device, researchers found it is possible to identify unique device. 

However, when we followed this trace and conduct a series of experiments, we soonly encountered a few obstacles. We set our adapter to only catch probe request frames and collected packets for a certain period of time. We did observe tons of probe request from different devices including cellphone, laptop and even IoT devices such as GoogleHome. However, when we target on cellphones only (Android and iPhone), it turns out these devices barely sent out probe requests, at least not with its unique MAC address. Soon we learn the term MAC Address Randomization - devices use random local MAC address to broadcast probe request to avoid tracking. According to this paper [A Study of MAC Address Randomization in Mobile Devices and When it Fails](https://arxiv.org/abs/1703.02874), most Android devices and iPhones since IOS 10 have adopted MAC address randomization technique. Therefore, fingerprinting smart devices via probe request is also not feasible. Although there are indeed ways to bypass MAC Adress Randomization, but that alone deserves another project. 

#### **Device Fingerprinting with WiFi Signature**
Finally, in the effort to search for other possible device fingerprint techniques, we came across a conference paper published by two Google Engineer two years ago [Passive Taxonomy of Wifi Clients using MLME Frame Contents](https://arxiv.org/abs/1608.01725). The author introduced a passive fingerprint method to identify the type of a client device (taxonomy) in the network with its unique "wifi-signature". With the mainstream adoption of 802.11n and 802.11ac, Wifi management frames contain a rich set of optional fields, capability bitmasks, and other information which vary substantially between different Wifi devices. By listing (in order) the parameters present in several common types of management frames, and extracting a few specific bitmasks from these frames, a highly specific signature can be developed. This signature is most strongly influenced by the chipset, which determines the values populated in the various capability bitmasks. It is next most strongly influenced by the device driver and wifi software stack, which determine the specific Information Elements present. Finally, a few values related to power levels and number of antennas are determined by the PCB board design. The combination of all of these can generally identify the model of the device.

![alt text][tag_param]

[tag_param]: https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/mgt%20frame%20tagged%20parameters.png

From the screenshot above, these tagged parameters reveal much information about the device itself such as supported data rates and supported transfer mode. Such capabilities are strongly associated with the hardware and software configuration of the device. That is why this method works so well. Note that the author also mentioned for similar devices such as iphone7 and iphone7s, their signature may look very similar as these products adopted very similar software and hardware configurations. Due to this reason, the accuracy of this method to identify every unique device is relatively low (a little above 50%) according to his experiment, however this approach still suits our project very well as long as this method could help to identify the type of the device. We do not really care about whether it is a iphone7 or iphone7S, as long as it could help us to determine it is an iphone, that will be good enough.

![alt_text][frame1]

[frame1]:https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/sig.png  

## **Implementation**

Following the Wifi dignature method, we implement our sniffing system and set it up in my apartment room which is about 100 sqare ft. It is a very wifi trafic noisey environment as there are dozens of devices not only in my room but also in my neighboors' units at different apartment floors. Thre are countless wifi-packets transmitting in the air at any point of time. 

**Hardware Setup**

![alt_text][hardware]

[hardware]: https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/hardware%20configuration.jpg

Hardware configuration is rather very simple. All we need is a Rpi board and a Wifi adaptor with monitor mode and packets injection capbilities. Monitor mode is just a mode the adaptor could operate with to capture wifi packets diretly from the air in regardless of its destination and source. The packet injection ability enables the adaptor to inject a 802.11 frame generated from our device in the air and directs it to its destination mac address.

**Software Support** 

Instead of use the default Rasperbian OS for our Rpi, we use Kali linux as our OS due to its fast kernel and inbuild tool for wifi packet manipulation. We use WireShark and Tcpdump for packets dump and inspection. Furthermore, two build-in tool of Kali linux are also used. Airodump-ng and Aireplay-ng are used for AP scanning and deauthentification attack. For porject develpment, we use Pycharm to write python scripts and git to synchronize project progress.

**Operation Overview**

![alt text][operation_overview]

[operation_overview]: https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/Overview.png

The diagram above shows the operation process of our script and it can be divided into four steps. The first three steps happens when our device is setting up. When the operation enters the passive phase, our device will passively monitor the network and generate occupancy report periodically (default every 30 mins).

**Setup and Scan for AP**

The setup process is really simple. First we need to initiate a series shell command to configure the adaptor to be in the monitor mode. Then we perform a AP scanning to scan all available AP nearby. Assuming that our device is placed close enough to the target AP, therefore, after getting a complete list of nearby AP and their SNR with the use of the tool Airodump-ng, we simply choose the one with the strongest SNR to be our target AP. We also configure our adaptor to only listen to the channel this AP operates on. 

**Active Phase**

Before introduing this operation phase, we would like to first explain what happens when a device connect to a AP. Upon its connection with the AP, device will first exchange six packets with AP: probe request/response, Authentification request/response and association request/response. After connection is initiated between user device and AP, a four-way handshake procedure takes place in which client exchange wifi password information with AP. This four-way handshape procedure has been a very well-known target for attackers to attempt to crack wifi password.

In our project, we are not interested in this four-way handshake process. As mentioned earlier, we need both probe request and association request frame to build unique wifi sigature for the user device. Thus, we are rather interested in the six packets exchange taking place at the very begining of the connection. For the purpose of our project, after we setup our device near a target AP, there will be already a few unknown devices connected to the network and will not send out these two types of packets we need as long as it stays in the network. We could simply wait for these device to leave the network some time in the future and take advantage of the moment they connect back to the network again, however that will simply be too time-consuming and inefficient. Instead, we adopt an active approach to actively identify these already connected devices in the network. That is also why we call this step of operation "Active Phase".

![alt text][Active_phase]

[Active_phase]: https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/Active%20Phase%20Algorithm.png

In order to identify devices already in the network, just as the algorithm psuedocode shown above, first we do a scan of all devices already connected to the AP and get a list of devices mac address. For each device in the list, we launch the deauthentification attack using the build-in tool aireplay-ng. Deauthentification attack is one type of DDOS attack which we created fake deauthentification packet and spoof the source mac address of the packet to be the AP mac address pretending we are the AP and send it out to the target device. As introduced eariler, deauthentification packets are sent when one side of the connection decided to terminate the communication. Deauthtification packets are also very easy to create as the header of 802.11 frame is simply plain text. With packet injection capbilities of our adapter, we could easily send out arbitrary number of deauth packets to victim device at any time. Once client device receive these packets, it will think AP needs to terminate the connection and so it will exit from the wifi network. After it exits the network, we then stop the attack. Since most device will automatically connect back with a known available AP, it creates a moment of re-connection for us to build the signature of the device and identify its type. Deauthentification attack is widely used by attackers to capture four-way handshake packets to decode wifi password. We borrow its idea here to capture the two packets of our interest. While we are launching the attack, at the same time we also are also monitoring the packets traffic in the air and capture these two packets of our interest to build the signature. In our experiments, our active method works unexpectedly well with 100% succcess rate.

**Passive Phase**

![alt text][passive_phase]

[passive_phase]: https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/passive%20phase%20algo.png

As the algorithm pusedocode shows above, the passive phase is rather very simple. After we identify all devices in the network, the operation enters the passive phase where our device will passively listen for any new connections and generate house occupancy every fixed period of time. When every a new device enters the network, its signature will be built and find a match in the database to identify its type. Its identity infomation and time it enters the network will be logged. 

Note that in the big loop of the passive listening periods there are subperiods. In these subperiods we use Tcpdump to collect packets for the duration of subperiod. After it finish its collection, we perform a packets analysis to collect packets of our interest and build signature if there is. While this packet analysis takes very little time (less than a few hundred ms), however we are not monitoring packets in the air at the meantime, therefore it is possible that we may miss some new connection at this moment. 

**Database match**

In order to identify the device, first we create the wifi signature of the device using tagged parameters of probe and association packets. Then we compare the signature with entries in a signature database where contains signatures of known types of devices. To perform the comparison, we calculate the hamming distance of two signatures by counting the number of different bytes in their signatures. The match is the signature of a known device in the database with the smallest hamming distance the unknown client device. 

We built a small database with about 10 devices we have in hand and divided into three catgories: smart phones, laptop and Iot devices. We have a few smartphones in the database such as iphone7, iphone7 plus, iphone6 and Huawei android phone. There are only two laptops: Macbook pro and Huawei portable laptop. There is also one Iot device, the Google Home I kept in the bedroom. Although we do not have many device in the database, ideally our script should still identify a unknown device correctly if it belongs to the same type of device (such as iphone7) as certain entry in database.

## **Results & Discussion**

[Occupancy Report 3/18/2018](https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/3_18_final_result_log.txt)

[Device log 3/18/2018](https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/3_18_device_log.txt)

[Occupancy Report 3/19/2018](https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/3_19_final_result.txt)

[Device log 3/19/2018](https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/3_19_device_log.txt)

[Occupancy Report 3/20/2018](https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/3_20_final_result.txt)

[Device log 3/20/2018](https://github.com/UCLA-ECE209AS-2018W/Cong-George/blob/master/3_20_device_log.txt)


These six documents showed the result our script genearted for three days. It successfully identified all devices in my room in the three-day period and accurately showed the occupancy. Occupancy will be determined as vacant when there are no smartphones present in the house. Furthermore, it successfully identified devices that were not logged in the database but belongs to the same type with certain entry in database despite the fact that sometimes it had hard time distinguishing between very similar devices such as iphone7 and iphone7s.

**Discussion**

Despite the high accuracy of our script, there are still some restriction in the current design and need improvements. Mentioned earilier in the passive phase section, currently the script still relies on tcpdump to dump packets and we can only do packet analysis after packets collection process is done. This may lead to potential miss log of devices that join during our analysis period. One improvment on this could be instead of relying on third-party tool to collect the packet, we could write customized C code to get the packet directly from the kernel and process it right after the fetch. This makes packects sniffing and analysis happen at the sam time and thus avoid packet loss. 

Another point worth bringing up about is the signature match finding process. As mentioned earlier, our database only contains about 10 entries. Therefore, signature comparison and match finding process takes very little time. However, imagine the case where the databse holds hundreds or even thousands of entries, time take to simply calculate the hamming distance one by one will be tremendous. This may slow down the whole process considerably and lead to packet miss. 

## Future Work
House occupancy detection is simply one application of this wifi signature method. There are many other potential applications this method could render as it provides a lightweight but really efficient method to identify the type of all devices in the network. This method could be used along with other device specific attack techniques. For example, after identifying a Nest Thermostats device in target house, one could further adopt the attack method introduce in the paper [Is Anybody Home? Inferring Activity From Smart Home Network Traffic](http://ieeexplore.ieee.org/document/7527776/?reload=true) which target Nest products. Future work could focus on how to take advantage of these identified devices. 

## Current Related Work
- In paper **"Is Anybody Home? Inferring Activity From Smart Home Network Traffic"**, the researchers are trying to infer personal information by investigating device-to-device and device-to-cloud smart home network traffic. They are using traffic analysis techniques on network traffic generated by NEST thermostats to deduce information about the presence of residents and other events occurring within the property. They first collect traffic data and perform data filtering by MAC address and Organization Unique Identifier(OUI), after they have collected all the data they begin to learn the pattern of the data flow of each device by traffic classification and focusing on the connection size and correlation analysis as criterial for classification.

- In paper **"Spying on the Smart Home: Privacy Attacks and Defenses on Encrypted IoT traffic**, the researchers demonstrate that an ISP or other network observer can infer privacy sensitivity in-home activities even when the device use encryption. They further prove that even with encryption, smart home traffic attack is achievable with meta-data only. Their attack includes the use of DNS queries or device fingerprinting to identify smart home devices from network traffic and infer user activities from changes in the device traffic rate.

- In paper **"Deep packet, A Novel Approach For Encrypted Traffic Classification Using Deep Learning"**, the group propose a deep learning based approach for traffic classification that integrates both feature extraction and classification steps, their network is able to classify FTP and P2P network classes and can distinguish between VPN and non-VPN network thanks to the nature and extend of CNN. Also in the paper "Network Traffic Classification using Support Vector Machine and Artificial Neural Network" the group is exploring other methods in machine learning domain to perform an effective network traffic classification.

 - At last, to implement our design, we are following a tutorial called **"Everything generates data: Capturing WiFi anonymous traffic using Raspberry Pi and WSO2 BAM"** to collect WiFi packet in Kali Linux environment.  

## Reference
[Shield: vulnerability-driven network filters for preventing known vulnerability exploits](https://www.semanticscholar.org/paper/Shield%3A-vulnerability-driven-network-filters-for-Wang-Guo/2d24d4ae048b4f5eb1fdc493eeba2a7b4d79fb2b)

[Network Traffic Classification using Support Vector Machine and Artificial Neural Network](https://pdfs.semanticscholar.org/618a/6e500e7fe53b5fbdecbb36d3db62b7d57676.pdf)

[Deep Packet: A Novel Approach For Encrypted Traffic Classification Using Deep Learning](https://arxiv.org/abs/1709.02656)

[Spying on the Smart Home: Privacy Attacks and Defenses on Encrypted IoT Traffic](https://arxiv.org/abs/1708.05044)

[Is Anybody Home? Inferring Activity From Smart Home Network Traffic](http://ieeexplore.ieee.org/document/7527776/)

[A Study of MAC Address Randomization in Mobile Devices and when it Fails](https://petsymposium.org/2017/papers/issue4/paper82-2017-4-source.pdf)

[On Security Vulnerabilities of Null Data Frames in IEEE 802.11 based WLANs](http://ieeexplore.ieee.org/document/5089319/?denied)

[Passive Taxonomy of Wifi Clients using MLME Frame Contents](https://arxiv.org/abs/1608.01725)

[Passive Data Link Layer 802.11 Wireless Device Driver FingerPrinting](https://pdfs.semanticscholar.org/54f5/359ef8434116511a66bb0d9bed02f6bed38f.pdf)

[Identify Unique Devices through Wireless FingerPrinting](https://dl.acm.org/citation.cfm?id=1352542&dl=ACM&coll=DL)


